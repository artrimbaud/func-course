# Chapter 5, lesson 3 #
Our final contract which is jetton wallet, both conceptually, code wise, it's one of the harder ones. And here, we probably won't discuss every line of the contract, since it's larger than the previous contracts that we've been discussing. But we'll still cover all the conceptual ideas that's happening here, because there are new things that haven't been discussed in NFT item or NFT collection. And approaches that have been taken here also quite interesting. So let's start. As always, we're discussing storage. And the search contains balance, owner address, jetton master Address, and jetton wallet code. We'll cover why each of those is needed later on. So let's just into receiving terminal method. Receiving terminal is since the beginning of receiving terminal is similar to the NFT collection, and NFT item, `etcetera`. So we're skipping empty message, loading the message and checking the facts. Unlike previous contracts, here, we're actually processing bounced message in case, because if we tried to burn or send notification and it failed, then we have to restore a balance back. So here we explicitly calling method on balance, we're checking the opcode of message that we've tried to send. And we're restoring balance if it didn't work, and we updating the storage with the new balance. So then again, it's the same code that you've been seeing in the previous contracts, then we're checking the opcode again. 
### Sending tokens ###
So let's start with the sending tokens.
In both of the methods, there is a signature for the method. So when you try to transfer token, you need to send query id, response destination, custom payload, maybe forward ton amount, forward payload, again. It means that for people maybe sent and it's not important, and it also creates internal transfer when sending message, but you're see it just in a moment. So we're loading query_id, we're loading jetton amount that we're loading the address. And after that we are forcing, we're validating that the blockchain we're on is the same word chain, we're trying to send tokens to after that for loading the data from storage. So balance, owner address master address all in code, and were deducting jetton amount from balance. Then we do any few checks that owner address and sender address are the same addresses. And we're checking that we have enough balance to actually send the tokens we're trying to send. Here's the interesting part. So in case address, we're trying to send tokens to doesn't have wallet for the this particular `jetton` or for any `jetton`. In fact, we going to create a jetton wallet for it. So we're creating state in it from the own from the following data, owner address jetton master address and wallet code. That's the reason why we need all that code in the first place. So we're creating state in it and we're calculating the ball at the address from the state in it. And from the statement you might remember the then we had the same thing in NFT collection. So here we are creating jetton wallets smart contract for address, we're trying to send tokens. And if the address already has wallet, then it doesn't matter, the staking gonna be ignored. But if it doesn't have, then we're gonna deploy a new contract. So then the loading the rest of the data response address custom payload forward amount, and we're checking. So if you, if you can see there is forward payload, this may be cell, so we check if the amount of data is zero or one. And so we're not, and we're just,
if not, then we're going to throw in there. And we're creating message. We're creating two messages. The first message is the message for a new wallet for. So we are using wallet address and the state_init. And the second message is for the wallet for receiving tokens. So what will happen is the wallet first getting deployed. And then we're going to process the receive internal method that we're going to discuss in a few minutes. So then we are checking that we have enough fees on our contract to actually send the message and we sending the message and updating the storage with the new balance. 
### receive tokens ###
Now the receive tokens. So receive tokens is somewhat similar. We loading data, query_id, jetton amount, and we're updating our balance where loading from address and response address, then we do a validation, we check that the message for receiving tokens is actually sent from the jetton wallet address. And that's from some new random contract. So we check if the center is either the master address or we calculate jetton wallet address from the from_address we get, and we check that it equals central address. So but basically, yeah, we just checking that the address that we're receiving message from ace jetton wallet address. And after that, we're checking if the message needs to be forwarded. And we're checking that we have enough fees for forwarding  the message?
### burned tokens ###
extra checking is therefore we're done amount is present. And if so, we're notifying the from address that the transfer has been successful. After that, we're checking if the response address is present as well. And if so, we're sending to that address all the money that has been not used. And we're just updating a new balance. That's the last method that the contract has is burned tokens that as the name suggests, it just decreases the balance and updates the master contract that the balance has been like this supply of tokens has been reduced. We're loading amount we want to burn. We're checking that we can do it, then the balance is present. And there's enough gas for burning tokens and that there is because we're going to send a few messages. And we're checking out the owner address and the central address are the same people and we just sending the message. We're reducing balance and sending the message this reduce supply from the master token, and we're updating the balance. Yeah, that's pretty much it the jetton wallet.
### fungible tokens ###
Let's discuss fungible tokens, or jettons. First, we're gonna start with the master contract. It's also called minter contract. So that's the both names, as the name suggests, is the contract that means the tokens and has information about total supply of the token. And it also has the information about token like, description, title, abbreviation. So let's start. As always, we've received internal similar to all the previous contracts, so we're skipping them to message and we're ignoring about bounced flags. Were check, we're loading operation code, query id, loading data, and checking if the operation is meant. We're loading all the necessary data from message and meeting tokens. Let's look at them in token method. So it's also really simple, basically, what it does it create initializes, a state for jetton wallet, contract, calculates address and sends the money to the address. So as we previously discussed, each address has its own jetton wallet. So in case if it's the first mean, then jetton wallet, it doesn't exist. And if it's not the first meant, then it still might not exist. And we still need to create one. I mean, if the address to which we meeting is the first one, we're definitely going to need to create the contracts were the first. That's why we creating stayed in it, and then calcualtes an adress, and that how mincing of tokens work. After that, we saving that total supply with that dated amount. And that's it. Similarly, the other option that the contract has is burned installations. So if you look at them, burning suffocation the only way to burn tokens is from the another wallet. So wallet contract sense information that tokens needs to be burned. And we're checking that the info was indeed sent from jetton wallet address. And if so, we're saving that total supply was decreased. After that, if the initial message contains response data, we're not defying the response address and sending the rest of the town that was sent with a message, there is also operation for changing admin and for changing content. And as you can see, there's a comment that the separation can be deleted, which is probably a good idea if you want to have immutable talking. But that's pretty much it. That's a simple contract. That just means or burns tokens and deploys the initial wallet. The wallet address is much more complex, and we're going to see it next. But before that, we're going to see other variations of a master contract
###  Mustard tokens ###
So in a data standard master contract also has another operation called provide all the address and it's used to calculate any jetton wallet from the address so when you want to know I just don't wallet address for any address, you just send the message with the operation provide wallet address and you get the response with calculated message. That's the updated standard. There's also another variation on minter contract code. `ICO minter`, basically if the operation is empty and message is empty, it has the code to buy tokens for done basically, `either` the message is empty and the amount of stone is appropriate. It is specified in the initial deploy obviously, then that token is going to get `mien` to your adress. So, if you want to have on gene Ico, that's the way to do it, there's a contract for it. That's it regarding mustard tokens, and the next we're going to talk about just on wallet itself.
