**TLB schema.**

Let's first discuss the NFT collection smart contract. And we'll start with discussing the storage scheme. Storage schema just describes the data that the contract contains. And it's usually described in so called TLB Schema. If you're familiar with it, great; if not, basically, it's a language that is used throughout the TON docks and FunC docks that just describes how data bytes are compacted. 

**NFT Collection and itâ€™s data types.**

NFT collection, as you can see, firstly, it has owner address and then next item index. The owner address is just in the main address that deployed this contract and that can manage it. As you will see, the owner address may be changed by the previous owner, so it's not static. The next item index is just the data that's passed on to NFT item. And it's also used for a bit of validation. The next two data types are collection content and common content. If you are not familiar with TLB schema specification, this symbol means that it's just a reference. So basically, the data after the next item index is just a reference that has two more references. So it's just the cell that has two other cells with content and common content. We will discuss in detail what the collection content and common content is in the next video, where we're going to discuss the NFT item smart contract. 

**NFT item**

So basically, all this data is just passed on to the NFT item. The NFT item code is the reference as it's specified in the cell. So it's the reference that's used for deploying the NFT item itself. So the NFT collection has an NFT item code. And it has this code because it's deployed with it, and it uses this code for deploying NFT items. That's how it's done.` And the next data is !rosebrides. !Row two params is specified above. So basically is also a reference that contains !Rosie factor, !row two base and !row two address.` All of this data is also for NFT items and not for an empty collection itself. Basically, everything past next item index is just the data that's passed on later for NFT item. 

**The internal method**

Now let's discuss the internal method, the main method of almost all smart contracts. As you can see, the first thing we do is check if the message contains any values at all. If not, we'll just skip in. Then we'll be checking the message flags and ignoring all bounced messages. After that, we load a few more data. So first we load center address, we load the opcode and we load `queer`. All this data will load in from the message, after which we load data from the storage. So as you can see, it's using the method load data that just loads data from the storage. It's pretty simple, there's really no need to look at that. Basically, it just loads all the data we previously discussed that specified in storage schema itself : owner address, next item index, content, NFT code and `!royalty params`. Both of this data is going to be used later. 
Okay, back to the code. After we've loaded all the necessary data, we check the opcode. You may find this unfamiliar, like where this `?arose` the params defined. And what actually happens is that the contracts are usually compiled with some supporting code, and in this particular case, the opcodes that are specified in the smart contract are provided in additional file during compilation. Here you can check the opcodes, which are basically just some random numbers that are specified as constant. So you just wouldn't have to remember the constant, and it will have some meaning. So basically, if the opcode is to get row to params, it just sends row to params back to the sender. The method itself isn't particularly useful; I wouldn't really know the practical use of it, but then there might be some use case where a smart contract would ask for `?relative params`, and based on the data, do something else. This is a standard contract and it has to be as broad and versatile as possible. But actual practical usage from this is low, and you probably wouldn't use it. 
So, back to the contract once again. As you can later see, what happens is that we're checking if the message sender, and the owner of the contract have the same addresses. Because although logic after it is for the owner only, basically all the rest of the logic is deploying NFTs or changing the owner itself. So we have to check that the sender and the owner are the same person and have the same address. 

**Deployment of a new NFT.**

How are new NFT's deployed? Basically, the first thing we're going to need is item index; we're taking it from message and checking against next item index. All we want to avoid is the deployment of an index of an item that's not supposed to be deployed. So we check if an item index is not bigger than the next item index. `If it's less than, or what we want is the next item index, obviously `. But if it's the previous item index, then we don't really care. The message is going to be sent, but nothing's going to happen. So we're fine with that as well. Then, we're checking if it's actually the last item index. We're going to use it after the deployment. And then we're going to deploy an object. What we need for deployment is item index, obviously, NFT code and NFT item code, then we need amount of money that's going to be sent with deployment message. And we're going to need content. The item index and content are provided with the initial message of deployment. So let's check that deploy NFT item method. So, as you can see, it accepts the parameters that we previously specified. And the next thing it does is calculate the state of a contract in it. How it does that? Well, it's a pretty standard way of creating state in it; you basically specify a few flags first, then you specify two cells: one cell that contains the code and the next cell that contains data. And then there is going to be another flag. We're not going to discuss the flags, because most of the time there are always `holds?`. And for the data, it basically just contains the item index and the owner like NFT collection address. 
So after that, we're going to need to calculate the NFT item address. That calculation of address is also a standard procedure. First, we're specifying a couple of flags, specifying work chain, calculating hash of state in it. And that's pretty much what an address is. It's just a hash of the content with the data, so it's easy to calculate. And after calculation, we're going to send the calculated NFC address, the state in it, and the provided content. That's it. Basically, what deploying NFT item does it is just sending a message to calculate the address with the predetermined content. 

**Batch deployment**

The next thing we're going to discuss is the batch deployment. Batch deployment is similar to the singular deployment. But if the message contains a reference to a reference cell with multiple contexts, then the NFTs can be deploed in batch. Maybe the most difficult line in the base deployment is this one. What happens is that it flows. So references must contain a dictionary. Dictionary where the key is an index and the value is an item. Delete gets the minimum key, deletes it, and returns the item, so it could be assigned.` The third value is ???` that means, whether the key was found or the dictionary is already empty. So until the dictionary is not empty, we're going to deploy NFT items. And the maximum number of items that can be deployed is 250, which is specified in comments and is limited. And after that, we just save the next item index. And that's it. 

**Summary**

So we've discussed the deployment of a singular NFT and deployment of a batch NFT. And the third opcode is just updating the owner. So basically, if the opcode is three, you could load an address from the specified message, and the address could be updated. 
That's pretty much the meat of NFC collection smart contract. And if you get` methods `(`?)`, that returns the collection data, which is just the owner address, next item index, and the content cell that we discussed in the very beginning. Then you can get NFT address by index from the collection. So basically, what happens is that the NFT item code is loaded from the storage and then the previously discussed method called Calculate NFT item state is used for state in it, and then that adress is generated as we already discussed, and same for `??? params`. It just flows row two params from data and returns it and same for NFT content; it just loads the data and returns it in itself. That's pretty much it for the NFT collection. Then, the next thing we're going to discuss is an NFT item. 
