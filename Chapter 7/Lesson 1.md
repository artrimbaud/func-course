# Chapter 5, lesson 2 #
### Storage description ###
Now that we have looked an NFT collection smart contract, let's dive in into the code on NFT item. We start off with the storage description, as always. So the storage is just the data that was passed into the contract by NFC collection, an index, collection address, owner address, and the content. If you check the receive internal method, you will see that beginning is very similar to NFT collection. So we'll just checking whether the message is internet beginning to parse the full message, checking flags, skipping bounds messages, and loading central address. After that we skipped a few more fields after reach we're calling load data method. Well, data returns five fields, whether the contract was initialized an index collection address owner address and content. While the leader for fields may be familiar, that it is an interesting one. So that when collection creates a contract, it just pass prices into a contract two values index and collection address, owner address and content is passed as a separate message. So when the NFC item is being deployed, it's actually not initialized, it doesn't have any owner address or content, the only thing it has is index and collection address. And owner and content is initialized with the message. So here we loading data. And if the contract wasn't previously initialized, we initializing by loading from the message will load on the address and from the message will load content as a reference. So before diving in deeper, let's check the load data. So the load data method it first fetches index and collection address from the data storage because it was initialized with the data, and then it checks whether the data storage contains any more data. So if the data storage has more data, then it means that the data has is owner address and content. If it doesn't, it means that contract wasn't initialized. So if the contract has any more bits besides the index and collection address, it returns minus one, which in fancy means true. Otherwise, it returns zero. And back to receive internal as we already said, if the contract is initialized it initializes the contract and that's it and if the execution stops. If the contract was previously initialized, we proceed, and we check the opcode of the message and clarity. The opcode may be one of two things with transfer ownership or getting the static data. Let's first discuss static data because it's extremely simple one as you can see here, a just sends the message with all the data it has. So it sends the index and collection dress would expect it to also send the content and owner address as well but I guess it doesn't. And if checking that transfer ownership we need to check the separate method. 
### Transfer ownership ###
Let's talk about transfer ownership. The second largest method in the whole contract. The first thing we do is we check whether we can transfer ownership by checking the central address and the owner address. And we throw an error if central address and owner address are two different addresses. After that, we loading address from the message, and we checking whether work chain of a new owner does the same as the work chain of a smart contract, basically, you cannot have owner address in different work chain as the NFT item. And we are enforcing that by thrown in there if the work chain is different. I mean, right now, we doesn't have any other work chains besides the there is only one work chain. But in theory, there may be multiple work chains if we need charging, and we need better scalability. So that's the checking of work chain is ideal for future proof. So the standard wouldn't have to be changed in the future when New Work chains appear. After that, we checked their response destination and whether it can be no. So, if their response destination is something we just also send the message that ownership was such a transfer of ownership was successful, but it can be no without any problem.

After that we check in may be `so rough`. So if you check the NFT item specification, you may see that transfer has the fields that we exactly load in here. So the new owner `querydy` that will load it in receive internal new owner response destination that will always in in transfer ownership and custom payload. Custom payload is a reference cell and reference cells, like maybe reference cells, the ones that may or may not exist, usually referenced by one date. It's either true or false. And here we're just skipping this bit altogether, because this particular NFT standard doesn't use custom payload a lot. After that we use forward amount. So after that, we'll always import them out and doing calculations to see whether what am I amount besides the forward amount we can send to risk as a response. So, do actually make it understandable that the message contains some value, it passed the smart contract and the balance of smart contract over the contains coins that should be sent over as a forward amount. So, what we do here is first we subtract from violence, `the amount of money that should amount of time` that should be used for storage. After that we subtract from this money amount that should be used for forwarding and also for forwarding gas. And if after that, we check if the former amount exists and forwarded basically to new address the new owner and if the response needed, so if the response destination exists, we send the rest of the money back to the response. So this is used for just accessing any taking excess of any amounts that were not used by the procession of transfer ownership. So that way, when you transfer you can pass more money just in case and everything that's not used gonna be sent back to you. And forward amount for notification is also used basically for notification, it's, there's not much logic. Besides that
it may be useful for wallets to get the message that they've been assigned `NFT` item and custodial or noncustodial wallets may use this message like they parse every message that volume gets. And based on the fact that it's NFT ownership, they may update their data. And it just useful for that purposes and nothing else. So I hope it's kind of clear. And the last line is that we store the new owner address. Now to recap, we checking that we can update the ownership, we're checking the Work chain, we're calculating the forward amounts and amounts that we sent back to the owner. We notifying new owner, and we sending back the rest of the money if needed. And after that, we save the data. And that's it. So I hope it is clear. Yeah, and we probably brush up on some of those 
### Souldbounds ###
`perfect like Dutch` is alternative NFT item contract. For example, here's the soul bound item contract that was presented a few months ago. And the polling country doesn't allow to be transferred at all. So we won't go into the full detail as we previously did with an NFT collection, and an NFT item collection. But I just wanted to give an example how NFT collection could possibly have not just one standard standard NFC item, but possibly other options. So for example, the same code for NFC collection can be used for deploying souldbound collection just by changing the following NFT and code. So just let's briefly talk about Soulbounds. Souldbounds in standard similar to NFT items but also allow for additional extensions, for example to be used as certificates by providing the ability to proving ownership. So it also allows like with certificates, there is also an option to revoke. So NFC collection or authority address can revoke the souldbound. So, let's briefly discuss the storage. As you can see, it has it is similar to NFT item, but it's a bit different. So the collection it has an index, collection address owner address, cell content, but also it has authority address and revoked at sell revoked ad is used when after authority address revoked the souldbound. And if this authority address is new, then it means that souldbound cannot be revoked or changed by anyone other than owner. So if you look at the code, you'll see that the only operations that souldbound can have is the request owner and prove ownership. So gets the data the same as a standard NFC item and destroy which is used for burning. If you look at them the same operation for transferring will cause an error. So if you tried to transfer it, it will just throws an error. As I said we won't go into the details of the contract as a It's not as important and it is very similar to NFT item, even though it may look very different, the concepts and ideas are very much the same. I just wanted to give an example how one NFT collection, like contracts for NFT collection can have different code for items underneath it. And the similar way you would extend the standard NFT item, right? So you would have NFT item and then extended with some additional logic that important for your project, even though the code would be different platforms like get jumps and others would still recognize it as NFT item because that get methods are the same. And so marketplaces like get gems doesn't actually check the contract by the source code, but by the get methods and by signatures on get methods. So, yeah, you can extend the standard contract as much as you want, just by leaving the get methods as they should. So, that's just a brief talk about souldbounds.
