Welcome to chapter one, lesson four, where we explore the concepts of contracts and accounts on the blockchain.

To start, it's important to note that contracts and accounts are essentially smart contracts. They are used to not only hold funds, but also to implement various entities such as tokens. These smart contracts are low-level building blocks, and in future lessons, we'll explore what high-level things can be built with them.

So, what exactly is a contract? Essentially, it's an entity on the blockchain that has its own state consisting of code, data, and the number of coins on its balance. These coins are not native to the contract, but rather they are synthetically created using other contracts and operate on top of this model.

Every contract also has a unique cryptographic identifier called an address. This address is a hash of the initial code and data used to design the contract, and while the code and data can be changed, the address remains constant.

As we discussed in the previous lesson, contracts have very local visibility and only see their code, data, and balance. When a contract receives an incoming message, it can emit any number of outgoing messages and also transform its state. Essentially, this means that contracts act as building blocks for various functionalities on the blockchain.

In the next section, we'll discuss some specific things that can be done with contracts, including wallet accounts and tokens.



Moving on to the things you can do with contracts, the first is the Wallet account. Every user has a wallet application where they hold their digital assets, including cryptocurrency like Tongue coins, using a wallet contract. This contract receives and checks messages with valid signatures, and transfers the digital assets as internal messages to other contracts in the network. For instance, to send 10 coins to someone, you would provide instructions in a message with a signature, which the recipient's wallet contract would then check, unwrap, and transfer to the next contract in the network.

Contracts can also implement tokens, which have properties like ownership or quantity. To transfer a token, you would send a message to the corresponding contract asking it to transfer the token to a new owner. The blockchain does not have a notion of balances of tokens on people's accounts, but rather sees contracts that send messages among themselves. People give meaning to contracts by interpreting them as tokens that can switch ownership and have value.

Finally, let's talk about the cost of executing contracts. A contract has to pay for its existence and operation, which consists of roughly three categories of payments. The first is gas payments for executing its code, which slowly eats away at the contract's balance every time an operation is performed. More expensive operations take more gas, and when the contract runs out of money, the operation fails. Outgoing messages are left unchanged unless they are explicitly committed by the sender, and the transaction fees are charged from the contract's balance. Developers must pay close attention to the cost of their operations and ensure they have enough balance to complete them, or risk running out of money or falling victim to a denial of service attack. There is also rent, which is charged to contracts when they are idle and have data in storage. The fee is charged per byte per second, and contracts must have enough money to pay the fee to remain active.


When a contract is not being used on a blockchain, it just sits there and has some data in its storage. Every contract has to pay a fee per byte per second, which is virtually charged every second but is actually charged when incoming transactions occur. Each contract knows when its last transaction occurred and can charge for the entire time since then when the next transaction arrives. For example, if your wallet contract hasn't been used for a month, your first transaction will have a noticeably higher fee because you're being charged for all the time that your contract's data has been sitting on all the nodes. If you immediately do another transfer, the second window will be much shorter, and the fee will be much smaller on the next transaction.

This is important to keep in mind for utility contracts, such as tokens, which must exist, hold state, and have some money on them to pay for their rent. It's the responsibility of the application or wallet developer to ensure that these tokens are kept alive by having enough money while they're being used. If you have limited lifetime tokens that need to exist for only a short time, you can put a small amount of money on them for one or two days, and then not worry about them because they will be eaten by the rent. However, if you have a long-term token, like a stablecoin, you need to recharge and refill it with coins to keep it alive for another year, which can be a conceptual difficulty in time.

Although there are fixed and variable fees for message routing, the fees are not expressed in terms of gas or rent. Instead, they are fees per byte of the message being sent. The strength of paying explicit costs for everything is that it ensures scalability and protection against denial of service attacks. In summary, this is an overview of the anatomy of accounts, contracts, and how they are used, including their key elements.
